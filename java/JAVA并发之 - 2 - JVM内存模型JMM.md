### 前言
前面我们简单描述了CPU是如何运行的，以及随着对性能的追求，从流水线的机器指令分阶段并行执行，到不断追求更快的主频的CPU，到主频提高到达瓶颈而产生的多核架构，聪明的科学家不断突破，将计算机性能提高了很多倍，但是今天的程序员在编写多线程程序时就会因为这些优化（编译器重排序，指令重排序，内存重排序）而在程序不能正常在多线程环境下运行，并且产生各种奇怪的现象而头疼，今天我们来聊聊JAVA虚拟机内存模型JMM在这个方面做出的努力。
### JMM - JAVA内存模型
#### happens-before  
happens-before是JMM当中最核心的概念，我们来看下JMM的设计意图：  
- 希望程序员看到的内存模型易于理解，易于编程，希望基于强内存模型来编写代码（前一篇文章有列过一个表格，内存模型越松散，编程难度越高）
- 编译器和处理器角度希望内存模型的束缚越少越好，这样就有可能利用各种手段机制优化性能。  

可见以上两条其实是相互矛盾的，所以JMM的设计者就需要找到一个折中的平衡点。  
下面我们看下，JSR-133中对happens-before关系的定义：  
- 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
- 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么折中重排序并不非法。  

笔者一开始看到这两个定义时，先是一头雾水，然后一头扎入了错误的理解中久久不能自拔，这里要说一下，所谓操作A happens-before 操作B，不是说操作A先于操作B发生，因为才多线程/多核环境下，除非使用类似锁这种阻塞线程的手段外，操作A及操作B分别在不相干的线程当中，他们的行为先后是不可预知的，这点一定要搞清楚。  
那么happens-before到底如何理解？  
实际上happens-before是指的内存可见性，我们可以理解所有的线程间通信可以以共享内存的方式进行，那么如果操作A和操作B都会修改变量a，那么由于CPU缓存的存在，A或B对变量a的修改不一定会立刻被对方可见，所以happens-before规则就描述的是，如果操作A happens-before 操作B，则A的操作结果，比如说变量a的赋值，立即对操作B可见。这个可见性的背后，可能是编译器在关键代码的位置增加了内存屏障，使写操作后立刻刷新主存，反正不管JMM如何对其进行实现，对于程序员来说，只要知道程序当中的happens-before关系，就能够写出正确同步的并发代码，JMM负责在happens-before规则框架下，保证内存序的同时尽可能压榨硬件/操作系统资源以提高性能。
##### happens-before规则
JSR-133定义的happens-before规则如下：
- 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。
- 监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。
- volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。
- 传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。
- start()规则：如果线程A执行操作ThreadB.start()，那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
- join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()成功返回。  

上面的规则，保证JMM及Java编译器在优化程序的时候，会根据happens-before规则，在合适的时机插入内存屏障，或者禁止某些重排序。
#### JVM提供的并发工具
##### volatile