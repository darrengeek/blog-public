### 前言
Redis作为一个经典，并且被大规模使用的分布式缓存中间件，其实现原理，使用，优化，乃至运维的方方面面，非常值得我们学习，它的学习资料也非常多，特别适合我们开启中间件学习的大门。这里由于笔者工作需要，需要将公司的近200个Redis实例容器化到K8S集群，所以专门对Redis进行一番学习，本系列作为笔者学习的笔记，用个人语言进行总结，不会像书籍中对原理阐述的细致系统。

下面是本人学习的主要大纲，后面也主要基于这个大纲展开
![](http://oss.zrbcool.top/picgo/Redis集群学习大纲.png)
### Redis Cluster
#### about slots hash
Redis集群选择虚拟槽的方式来创建管理集群，集群使用16384个slots管理所有集群数据，key到slots的映射使用CRC16计算hash值后对16383求余，使用虚拟槽的好处是由于slots数固定，当增加节点的时候，由管理员来分配管理节点与slots的映射关系，进而避免了根据节点数求余的方式在增加节点时50%数据需要迁移的问题。
  另外，还有一种方式是一致性hash，这种使用虚拟节点的方式虽然减少了节点变化时影响数据的比例，但是有一些问题，例如：节点变化时，会造成hash环中部分数据无法命中，需要手动处理或者忽略这部分数据；节点数量较少时，节点变化一致性hash的影响范围较大。
  
#### key slot calc
集群使用CRC16(key) % 16383的方式计算出slot，并根据客户端缓存的slot与节点映射关系选择节点连接（或随机）发起数据处理请求，如果服务器端slot与节点关系发生变化，收到请求的服务器会回复MOVED给客户端，客户端重新获取集群的节点与slot映射关系后，重新发起请求。还有一种情况是，key所在slot正在进行迁移，且该key已经被迁移到目标节点，同时整个slot并未完全迁移完成。这种情况服务器会给客户端回复ASK错误，表示一种临时变更状态，客户端向目标节点发出ASKING，然后再发起数据请求。后面说到迁移时会详细展开这部分。

#### hash tag
Redis集群的机制避免了代理模式的性能损耗，但是由于其key分散的特点，mget等批量操作如操作key的集合不都在一个节点上时，会导致服务器返回MOVED错误，在客户端一方，我们可以在请求前对key集合的每个key提前计算CRC16并计算slot信息，将批量请求按照节点分批发送。另外，Redis集群提供一种hash tag的方式解决这个问题，就是在key中{}包含的部分，服务器会基于{}中的部分计算CRC16的值而不是整个key，这样就能够保证所有同样hash tag的数据一定都会在一个slot上，对于同样hash tag的批量操作及事务操作就能够支持。但是这里需要注意一点，在设计key时，要避免{}的范围过大，要尽量将业务变量如userId放入hash tag，否则可能会导致某个slot的数据量巨大，进而导致集群的数据分配不均衡。

#### epoch

#### PING/PONG

#### reshard

### 问题
#### 如何保证节点间均匀

### 扩展
#### 节点数hash，一致性hash，虚拟槽方式的区别，优劣对比
#### gossip协议
Gossip是一种去中心化思路的分布式协议，解决状态在集群中的传播和状态一致性的保证两个问题。
Gossip在去中心化的结构下，通过信息的部分传递，达到全集群的状态信息传播，传播的时间收敛在O(Log(N))以内，其中N是节点的数量。同时基于Gossip协议，可以构建出状态一致的各种解决方案。
